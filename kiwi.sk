namespace Kiwi {
  var _int32 = Int32Array.new(1)
  var _float32 = Float32Array.new(_int32.buffer)

  class DecodeError {
    const message string
  }

  namespace DecodeError {
    def throwOutOfBounds {
      throw new("Index out of bounds")
    }

    def throwInvalidMessage {
      throw new("Attempted to parse invalid message")
    }

    def throwInvalidEnumValue(name string) {
      throw new("Invalid value for enum \"\(name)\"")
    }

    def throwMissingRequiredField(name string) {
      throw new("Missing required field \"\(name)\"")
    }

    def throwInvalidSchema {
      throw new("Invalid schema")
    }
  }

  class ByteBuffer {
    var _index = 0
    var _length = 0
    var _data Uint8Array = null

    def new {
      _data = Uint8Array.new(256)
    }

    def new(data Uint8Array) {
      _data = data
      _index = 0
      _length = data.length
    }

    def toUint8Array Uint8Array {
      return _data.subarray(0, _length)
    }

    def readByte int {
      if _index + 1 > _length {
        DecodeError.throwOutOfBounds
      }
      return _data[_index++]
    }

    def readVarFloat double {
      var index = _index
      var data = _data

      # Optimization: use a single byte to store zero
      if index + 1 > _length {
        DecodeError.throwOutOfBounds
      }
      var first = data[index]
      if first == 0 {
        _index = index + 1
        return 0
      }

      # Endian-independent 32-bit read
      if index + 4 > _length {
        DecodeError.throwOutOfBounds
      }
      var bits = first | (data[index + 1] << 8) | (data[index + 2] << 16) | (data[index + 3] << 24)
      _index = index + 4

      # Move the exponent back into place
      bits = (bits << 23) | (bits >>> 9)

      # Reinterpret as a floating-point number
      _int32[0] = bits
      return _float32[0]
    }

    def readVarUint int {
      var value = 0
      var shift = 0

      while true {
        var byte = readByte
        value |= (byte & 127) << shift
        shift += 7

        if (byte & 128) == 0 || shift >= 35 {
          break
        }
      }

      return value
    }

    def readVarInt int {
      var value = readVarUint
      return (value & 1) != 0 ? ~(value >>> 1) : value >>> 1
    }

  def _readVarUint64Bin string {
    var byteCount = 0
    var binStr = ""
    while true {
      var byte = readByte
      if byteCount < 8 {
        var binStrByte = _convertBase((byte & 127).toString, 10, 2)
        binStr = "0".repeat(7 - binStrByte.count) + binStrByte + binStr
      } else {
        binStr = _convertBase(byte.toString, 10, 2) + binStr
        break
      }
      byteCount += 1
      if (byte & 128) == 0 {
        break
      }
    }
    return binStr
  }

  def readVarUint64 string {
    var temp = _readVarUint64Bin
    return _convertBase(temp, 2, 10)
  }

  # see encoding strategy at writeVarInt64()â€“ this function does the opposite
  def readVarInt64 string {
    var binValue = _readVarUint64Bin
    if binValue.slice(Math.max(0, binValue.count - 1)) == "1" {
      var binArr = _parseToDigitsArray(binValue.slice(0, Math.max(0, binValue.count - 1)), 2)
      binArr = _add(binArr, [1], 2)
      return "-" + _convertBase(_parseFromDigitsArray(binArr, 2), 2, 10)
    } else {
      return _convertBase(binValue.slice(0, Math.max(0, binValue.count - 1)), 2, 10)
    }
  }

    def readString string {
      var result = ""

      while true {
        var codePoint = 0

        # Decode UTF-8
        var a = readByte
        if a < 0xC0 {
          codePoint = a
        } else {
          var b = readByte
          if a < 0xE0 {
            codePoint = ((a & 0x1F) << 6) | (b & 0x3F)
          } else {
            var c = readByte
            if a < 0xF0 {
              codePoint = ((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F)
            } else {
              var d = readByte
              codePoint = ((a & 0x07) << 18) | ((b & 0x3F) << 12) | ((c & 0x3F) << 6) | (d & 0x3F)
            }
          }
        }

        # Strings are null-terminated
        if codePoint == 0 {
          break
        }

        # Encode unicode
        result += string.fromCodePoint(codePoint)
      }

      return result
    }

    def _growBy(amount int) {
      assert(amount > 0)

      if _length + amount > _data.length {
        var data = Uint8Array.new(_length + amount << 1)
        data.set(_data)
        _data = data
      }

      _length += amount
    }

    def writeByte(value int) {
      assert(0 <= value && value <= 255)
      var index = _length
      _growBy(1)
      _data[index] = value
    }

    def writeVarFloat(value double) {
      var index = _length

      # Reinterpret as an integer
      _float32[0] = value
      var bits = _int32[0]

      # Move the exponent to the first 8 bits
      bits = (bits >>> 23) | (bits << 9)

      # Optimization: use a single byte to store zero and denormals (check for an exponent of 0)
      if (bits & 255) == 0 {
        writeByte(0)
        return
      }

      # Endian-independent 32-bit write
      _growBy(4)
      var data = _data
      data[index] = bits
      data[index + 1] = bits >> 8
      data[index + 2] = bits >> 16
      data[index + 3] = bits >> 24
    }

    def writeVarUint(value int) {
      while true {
        var byte = value & 127
        value >>>= 7
        writeByte(value != 0 ? byte | 128 : byte)
        if value == 0 {
          break
        }
      }
    }

    def writeVarInt(value int) {
      writeVarUint((value << 1) ^ (value >> 31))
    }

    # returns -1 if incorrect input
    def _parseInt(binValue string, base int) int {
      var value = 0
      for i = 0; i < binValue.count; i++ {
        var currBin = binValue[binValue.count - i - 1]
        if currBin < 48 || currBin > 57 {
          return -1
        }
        value += (binValue[binValue.count - i - 1] - 48) * (Math.pow(base, i) as int)
      }
      return value
    }

    def _writeVarUint64Helper(binValue string) {
    if binValue  == "" {
      return
    }

    var byteCount = 0
    while true {
      if byteCount > 7 {
        var byte = _parseInt(binValue.slice(Math.max(binValue.count - 8, 0)), 2)
        binValue = binValue.slice(0, Math.max(binValue.count - 8, 0))
        writeByte(byte)
        break
      }
      var byte = _parseInt(binValue.slice(Math.max(binValue.count - 7, 0)), 2)
      binValue = binValue.slice(0, Math.max(binValue.count - 7, 0))
      writeByte(binValue != "" ? byte | 128 : byte)
      byteCount += 1
      if binValue == "" {
        break
      }
    }
  }

  def writeVarUint64(value string) {
    value = _cleanNumericString(value)
    var binValue = _convertBase(value, 10, 2)
    _writeVarUint64Helper(binValue)
  }

  # Given a binary string, this subtract 1 and return result
  def _subtractOne(digits string) string {
    var borrow = 1
    var result = digits.codePoints
    for i = result.count - 1; i >= 0; i-- {
      if result[i] - 48 < borrow {
        result[i] = 49
      } else {
        result[i] = 48
        borrow = 0
        if i == 0 {
          result = result.slice(1)
        }
        break
      }
    }
    return string.fromCodePoints(result) # Removes extra prefixed zeroes
  }

  def _cleanNumericString(value string) string {
    var numericString = ""
    for i = 0; i < value.count; i++ {
      const char = value[i]
      if (char >= '0' && char <= '9') || (i == 0 && char == '-') {
        numericString += string.fromCodePoint(char)
      }
    }
    return numericString
  }

  # Variable length encoding is done as follows
  # Move the sign bit to the RHS
  # If value is negative, flip all the bits (except sign bit) and subtract 2 (to skip over the sign bit on the right)
  def writeVarInt64(value string) {
    value = _cleanNumericString(value)
    var binValue = ""
    if value == "" {
      return # FLAG error
    }
    if value[0] != '-' {
      binValue = _convertBase(value, 10, 2) + "0"
    } else {
      binValue = _convertBase(value.slice(1), 10, 2)
      if binValue == "0" || binValue == "" {
        writeVarUint64("0")
        return
      }
      binValue = _subtractOne(binValue) + "1"
    }
    _writeVarUint64Helper(binValue)
  }
    var arrToString = (inp List<int>) string => {
      var ret = ""
      for i = 0; i < inp.count; i++ {
        ret += inp[i].toString
      }
      return ret
    }
  # add(), multiplyByNumber(), parseToDigitsArray(), parseFromDigitsArray(), are all helper functions for convertBase()
  def _add(x List<int>, y List<int>, base int) List<int> {
    const z List<int> = []
    const n = Math.max(x.count, y.count)
    var carry = 0
    var i = 0
    while i < n || (carry != 0) {
      const xi = i < x.count ? x[i] : 0
      const yi = i < y.count ? y[i] : 0
      const zi = carry + xi + yi
      z.append(zi % base)
      carry = Math.floor(zi / base) as int
      i++
    }

    return z
  }

  def _multiplyByNumber(num int, x List<int>, base int) List<int> {
    if num < 0 { return [] }
    if num == 0 { return [] }

    var result List<int> = []
    var power = x
    while true {
      if (num & 1) != 0 {
        result = _add(result, power, base)
      }
      num = num >> 1
      if num == 0 { break }
      power = _add(power, power, base)
    }

    return result
  }

  def _parseToDigitsArray(str string, base int) List<int> {
    const digits = str.toString.split("")
    const ary List<int> = []
    for i = digits.count - 1; i >= 0; i-- {
      const n = _parseInt(digits[i], base)
      if n == -1 { return [] }
      ary.append(n)
    }
    return ary
  }

    def _parseFromDigitsArray(arr List<int>, base int) string {
      var out = ""
      for i = arr.count - 1; i >= 0; i-- {
        out += arr[i].toString
      }
      return out
    }

    # Used to help convert numerical strings between bases.
    # This is a necessary step when encoding 64bit int js strings into a byte buffer
    def _convertBase(str string, fromBase int, toBase int) string {
      const digits = _parseToDigitsArray(str, fromBase)
      if digits == null { return ""}

      var outArray List<int> = [0]
      var power List<int> = [1]
      for i = 0; i < digits.count; i++ {
        if digits[i] != 0 {
          outArray = _add(outArray, _multiplyByNumber(digits[i], power, toBase), toBase)
        }
        power = _multiplyByNumber(fromBase, power, toBase)
      }
      return _parseFromDigitsArray(outArray, toBase)
    }

    def writeString(value string) {
      var iterator = Unicode.StringIterator.INSTANCE.reset(value, 0)

      while true {
        # Decode unicode
        var codePoint = iterator.nextCodePoint
        if codePoint == -1 {
          break
        }

        # Strings are null-terminated
        assert(codePoint != 0)

        # Encode UTF-8
        if codePoint < 0x80 {
          writeByte(codePoint)
        } else {
          if codePoint < 0x800 {
            writeByte(((codePoint >> 6) & 0x1F) | 0xC0)
          } else {
            if codePoint < 0x10000 {
              writeByte(((codePoint >> 12) & 0x0F) | 0xE0)
            } else {
              writeByte(((codePoint >> 18) & 0x07) | 0xF0)
              writeByte(((codePoint >> 12) & 0x3F) | 0x80)
            }
            writeByte(((codePoint >> 6) & 0x3F) | 0x80)
          }
          writeByte((codePoint & 0x3F) | 0x80)
        }
      }

      # Strings are null-terminated
      writeByte(0)
    }
  }

  class BinarySchema {
    var _definitions List<Definition> = []

    def parse(bb ByteBuffer) {
      _definitions = []
      var definitionCount = bb.readVarUint

      for i in 0..definitionCount {
        var name = bb.readString
        var kind = bb.readByte as Kind
        var fields List<Field> = []

        if kind != .ENUM && kind != .STRUCT && kind != .MESSAGE {
          DecodeError.throwInvalidSchema
        }

        for j in 0..bb.readVarUint {
          var field = Field.new(bb.readString, bb.readVarInt, bb.readByte as bool, bb.readVarUint)
          if field.type < TYPE_STRING || field.type >= definitionCount {
            DecodeError.throwInvalidSchema
          }
          fields.append(field)
        }

        _definitions.append(Definition.new(name, kind, fields))
      }
    }

    def findDefinition(definition string) int {
      for i in 0.._definitions.count {
        if _definitions[i].name == definition {
          return i
        }
      }

      # Ignore fields we're looking for in an old schema
      return -1
    }

    def skipField(bb ByteBuffer, definition int, field int) {
      if definition >= 0 && definition < _definitions.count {
        for item in _definitions[definition].fields {
          if item.value == field {
            _skipField(bb, item)
            return
          }
        }
      }

      Kiwi.DecodeError.throwInvalidMessage
    }

    def _skipField(bb ByteBuffer, field Field) {
      for i in 0..field.isArray ? bb.readVarUint : 1 {
        switch field.type {
          case TYPE_BOOL, TYPE_BYTE { bb.readByte }
          case TYPE_INT, TYPE_UINT { bb.readVarUint }
          case TYPE_INT64, TYPE_UINT64 {bb.readVarUint64 }
          case TYPE_FLOAT { bb.readVarFloat }
          case TYPE_STRING { while bb.readByte != 0 {} }

          default {
            assert(field.type >= 0 && field.type < _definitions.count)
            var definition = _definitions[field.type]

            switch definition.kind {
              case .ENUM { bb.readVarUint }
              case .STRUCT { for nested in definition.fields { _skipField(bb, nested) } }
              case .MESSAGE {
                while true {
                  var id = bb.readVarUint
                  if id == 0 { break }
                  skipField(bb, field.type, id)
                }
              }
              default { assert(false) }
            }
          }
        }
      }
    }
  }

  namespace BinarySchema {
    const TYPE_BOOL = -1
    const TYPE_BYTE = -2
    const TYPE_INT = -3
    const TYPE_UINT = -4
    const TYPE_FLOAT = -5
    const TYPE_STRING = -6
    const TYPE_INT64 = -7
    const TYPE_UINT64 = -8

    class Field {
      const name string
      const type int
      const isArray bool
      const value int
    }

    enum Kind {
      ENUM
      STRUCT
      MESSAGE
    }

    class Definition {
      const name string
      const kind Kind
      const fields List<Field>
    }
  }
}
